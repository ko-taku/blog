<h2>20250204 TIL</h2>
<article>
    <h3>타임스탬프 해시 생성과정</h3>
    <ul>
        <li><strong>입력 데이터의 해시 생성</strong>: 입력 데이터를 해시 함수(예: SHA-256)에 통과시켜 고정된 길이의 해시 값을 생성합니다.</li>
        <li><strong>타임스탬프 기관에 제출</strong>: 생성된 해시 값을 타임스탬프 기관에 제출합니다. 기관은 해당 해시 값에 타임스탬프를 추가하고, 디지털 서명을 통해 데이터를 인증합니다.
        </li>
        <li><strong>타임스탬프와 서명 반환</strong>: 타임스탬프 기관은 타임스탬프와 서명이 포함된 결과를 사용자에게 반환합니다.</li>
        <li><strong>데이터 검증</strong>: 나중에 데이터를 검증하려면, 사용자가 원본 데이터에서 해시 값을 다시 계산한 후, 기관이 제공한 해시 값을 비교합니다. 해시 값이 일치하면 데이터가
            변조되지 않았음을 확인할 수 있습니다.</li>
        <li><strong>체인 구조 (선택적)</strong>: 여러 타임스탬프를 체인 형태로 연결하여 이전 타임스탬프의 해시 값을 포함시킬 수도 있습니다. 이를 통해 데이터의 시간 순서와 무결성을
            보장합니다.</li>
    </ul>

    <h3>SHA-256 알고리즘 요약</h3>
    <ul>
        <li><strong>입력 데이터 처리</strong>: 입력된 데이터는 아스키 코드로 표현된 이진 데이터로 변환됩니다. 데이터는 512비트 블록 단위로 처리되며, 크기가 모자라면 패딩을 추가하여
            512비트를 맞춥니다.</li>
        <ul>
            <li>패딩: 데이터의 끝에 1비트를 추가하고, 이후 0비트로 채웁니다.</li>
            <li>마지막 블록에는 64비트 길이 정보가 추가되어 총 512비트를 맞추게 됩니다.</li>
        </ul>
        <li><strong>초기 해시값</strong>: SHA-256은 8개의 32비트 초기 해시값을 사용합니다. 이 값은 상태 변수로, 입력 데이터의 블록들이 처리되는 동안 계속해서 갱신됩니다.</li>
        <li><strong>메시지 블록 처리</strong>: 입력 데이터는 512비트 블록 단위로 처리됩니다. 각 블록은 32비트 단위로 나누어 16개의 워드로 시작합니다. 이후 메시지 스케줄을 통해
            16개의 워드를 기반으로 48개의 새로운 워드를 생성하여 총 64개의 워드가 됩니다.</li>
        <ul>
            <li>처음 16개 워드는 입력 데이터에서 직접 파생됩니다.</li>
            <li>이후 48개 워드는 입력 데이터와 관계 없는 값들로, 기존 워드들을 바탕으로 연산을 통해 생성됩니다.</li>
        </ul>
        <li><strong>라운드 처리</strong>: SHA-256은 64번의 라운드로 이루어져 있으며, 각 라운드에서 상태 변수가 업데이트됩니다. 상태 변수는 각 라운드마다 계산을 통해 계속 변화하고,
            최종적으로 최종 해시값을 계산하는 데 사용됩니다.</li>
        <li><strong>최종 해시값 생성</strong>: 64번의 라운드 처리가 끝난 후, 8개의 상태 변수 값 (H0 ~ H7)은 256비트의 최종 해시값으로 결합됩니다.</li>
    </ul>

    <h3>비트코인 블록체인 주요 요소</h3>
    <ul>
        <li><strong>블록 해시</strong>: 블록 해시는 블록 간 연결성을 유지하고, 변경된 데이터를 탐지하는 역할을 합니다.</li>
        <li><strong>작업 증명 (Proof of Work)</strong>: 비트코인 채굴자는 새로운 블록을 블록체인에 추가하기 위해 해시 퍼즐을 풀어야 합니다. 이 과정을 작업 증명이라고 하며,
            네트워크의 보안성을 높입니다.</li>
        <li><strong>트랜잭션 ID</strong>: 각 트랜잭션에는 트랜잭션 ID가 존재하며, 이는 트랜잭션의 변경 여부를 확인하고 무결성을 보장합니다.</li>
        <li><strong>머클 트리</strong>: 머클 트리는 블록 내의 모든 트랜잭션을 요약하고, 데이터 검증 및 효율적인 검색을 가능하게 하는 중요한 기술입니다.</li>
        <li><strong>비트코인 주소</strong>: 비트코인 주소는 비대칭키 암호화에서 공개키를 해싱하여 생성됩니다.</li>
        <li><strong>디지털 서명</strong>: 디지털 서명은 트랜잭션의 무결성을 보장하고, 소유권을 증명하는 데 중요한 역할을 하며, 이 과정에서 해시 함수가 사용됩니다.</li>
    </ul>

    <h3>암호화 개념 및 블록체인에서의 활용</h3>

    <h4>암호화와 복호화</h4>
    <ul>
        <li><strong>암호화</strong>: 원본 데이터를 비밀 키를 사용하여 암호문으로 변환.</li>
        <li><strong>복호화</strong>: 암호화 과정에서 사용한 키로 암호문을 다시 평문으로 변환.</li>
    </ul>

    <h4>대칭키 암호화 (Symmetric Key Encryption)</h4>
    <ul>
        <li><strong>장점</strong>: 상대적으로 빠르고 효율적.</li>
        <li><strong>단점</strong>: 동일한 키를 공유해야 하므로 안전하게 키를 교환하는 방법이 필요.</li>
        <li><strong>예시</strong>: AES (파일 보호, 인터넷 뱅킹), DES, RC4 (스트리밍, VPN)</li>
    </ul>

    <h4>비대칭키 암호화 (Asymmetric Key Encryption)</h4>
    <ul>
        <li><strong>과정</strong>: 개인 키를 16진수 문자열로 변환한 뒤, Base58Check 인코딩 방식으로 변환하여 사용자가 쉽게 보관하고 관리할 수 있게 함. 공개 키는 개인 키로부터
            생성되며, 공개 키에서 개인 키를 유추할 수 없고, 개인 키에서 공개 키를 유추할 수 있음.</li>
    </ul>

    <h4>공개 키로 암호화 (Public Key Encryption)</h4>
    <ul>
        <li><strong>기밀성 보장</strong>: 공개 키로 암호화한 데이터는 해당 개인 키만으로 복호화 가능합니다.</li>
        <li><strong>예시</strong>: TLS/SSL을 통한 보안 웹 통신 (HTTPS), SSH (Secure Shell), 암호화된 이메일 (PGP/GPG), 클라우드 저장소에서의 데이터
            암호화</li>
    </ul>

    <h4>개인 키로 암호화 (Private Key Encryption)</h4>
    <ul>
        <li><strong>디지털 서명</strong>: 개인 키로 암호화한 데이터는 공개 키를 통해 변경되었는지 여부를 확인할 수 있습니다.</li>
        <li><strong>예시</strong>: 디지털 서명 (데이터의 무결성 및 송신자 인증), 암호화폐 (거래의 인증 및 보안), 전자서명 (계약서, 문서 서명), 전자투표 시스템 (투표의 무결성 및
            익명성 보장)</li>
    </ul>

    <h3>블록체인에서의 공개키 및 개인키 활용</h3>
    <ul>
        <li><strong>공개 키</strong>: 블록체인 주소 생성에 사용, 디지털 서명을 검증할 때 사용.</li>
        <li><strong>개인 키</strong>: 트랜잭션 서명에 사용, 블록체인 자산의 소유권을 증명.</li>
    </ul>

    <h3>디지털 서명</h3>
    <ul>
        <li><strong>디지털 서명 생성</strong>: 송신자의 개인 키를 사용하여 해시 값에 서명을 생성합니다. 서명은 암호화된 해시 값으로, 데이터의 무결성과 진위성을 보증합니다.</li>
        <li><strong>서명 검증</strong>: 수신자는 송신자의 공개 키로 서명을 복호화하고, 원본 데이터를 해싱한 값과 복호화된 값을 비교하여 변조 여부를 확인합니다.</li>
    </ul>

    <h3>타임스탬프에서의 디지털 서명 사용 목적</h3>
    <ul>
        <li>데이터의 무결성을 증명하고, 데이터의 시간을 인증하여 신뢰를 제공합니다.</li>
    </ul>

    <h3>비트코인에서 디지털 서명의 역할</h3>
    <ul>
        <li>트랜잭션 무결성을 보장</li>
        <li>소유권을 증명</li>
        <li>탈중앙화된 검증 (중앙 기관 없이 신뢰를 유지)</li>
        <li>ECDSA(타원 곡선 디지털 서명 알고리즘)를 사용하여 서명을 생성하고 검증</li>
        <li>비트코인 주소는 공개 키를 해싱하여 생성됩니다 (SHA-256 + RIPEMD-160)</li>
        <li>디지털 서명은 64바이트 크기로 트랜잭션 데이터에 포함됩니다.</li>
    </ul>
    <h3>OpenSSL을 이용한 ECC 개인 키와 공개 키 생성</h3>
    <p>OpenSSL의 ECC 함수를 사용하여 개인 키와 공개 키 쌍을 생성하는 방법을 CLI(Command Line Interface) 방식으로 설명합니다.</p>

    <h3>1. OpenSSL에서 지원되는 타원곡선 목록 확인</h3>
    <p>OpenSSL을 이용하여 지원되는 타원곡선 목록을 확인하려면 다음 명령어를 사용합니다:</p>
    <ul>
        <li><code>% openssl ecparam -list_curves</code></li>
    </ul>
    <p>이번에 사용할 타원곡선은 비트코인에서 사용하는 <strong>secp256k1</strong>입니다.</p>

    <h3>2. 개인 키 생성</h3>
    <p>다음 명령어를 사용하여 secp256k1 타원곡선 기반의 개인 키를 생성합니다:</p>
    <ul>
        <li><code>% openssl ecparam -name secp256k1 -genkey -noout -out privatekey.pem</code></li>
    </ul>

    <h3>3. 생성된 개인 키 확인</h3>
    <p>생성된 개인 키를 확인하려면 다음 명령어를 사용합니다:</p>
    <ul>
        <li><code>% cat privatekey.pem</code></li>
    </ul>

    <h3>4. 공개 키 생성</h3>
    <p>개인 키로부터 공개 키를 생성하려면 다음 명령어를 사용합니다:</p>
    <ul>
        <li><code>% openssl ec -in privatekey.pem -pubout -out pubkey.pem</code></li>
    </ul>

    <h3>5. 생성된 공개 키 확인</h3>
    <p>생성된 공개 키를 확인하려면 다음 명령어를 사용합니다:</p>
    <ul>
        <li><code>% cat pubkey.pem</code></li>
    </ul>

    <h3>6. 개인 키의 상세 정보 출력</h3>
    <p>개인 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다:</p>
    <ul>
        <li><code>% openssl ec -in privatekey.pem -text -noout</code></li>
    </ul>
    <p>출력 내용 설명:</p>
    <ul>
        <li><strong>read EC key:</strong> 입력된 키 파일이 타원 곡선 알고리즘에 적합한 키 파일임을 확인</li>
        <li><strong>Private-Key:</strong> (256 bit): 개인 키의 크기 (256 비트)</li>
        <li><strong>priv:</strong> 개인 키의 값</li>
        <li><strong>pub:</strong> 공개 키의 값. 공개 키는 개인 키와 타원 곡선의 기준점을 곱하여 계산됩니다.</li>
        <li><strong>공개 키의 형태:</strong>
            <ul>
                <li>첫 번째 바이트: 04 (비압축 공개 키를 나타냄)</li>
                <li>나머지 값: x와 y 좌표를 16진수로 나열한 값</li>
            </ul>
        </li>
    </ul>

    <h3>7. 공개 키의 상세 정보 출력</h3>
    <p>공개 키에 대한 상세 정보를 출력하려면 다음 명령어를 사용합니다:</p>
    <ul>
        <li><code>% openssl ec -in pubkey.pem -pubin -text -noout</code></li>
    </ul>

    <h3>8. 공개 키로 개인 키를 유추할 수 없는 이유</h3>
    <p>개인 키에서 공개 키를 계산할 수 있지만, 공개 키에서 개인 키를 유추하는 것은 불가능합니다. 그 이유는 다음과 같습니다:</p>
    <ul>
        <li><strong>이산 로그 문제:</strong> 타원 곡선에서 특정 점을 기반으로 역연산을 하는 것이 매우 어렵기 때문입니다.</li>
        <li><strong>연산의 비대칭성:</strong> 공개 키에서 개인 키를 추출하는 계산은 매우 복잡하고 시간 복잡도가 높습니다.</li>
        <li><strong>타원 곡선의 높은 보안성:</strong> 타원 곡선 기반 암호화는 매우 높은 보안성을 제공합니다.</li>
    </ul>
</article>