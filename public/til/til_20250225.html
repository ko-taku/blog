<h2>20250225 TIL</h2>
<article>
    <h3>객체지향 프로그래밍</h3>
    <ul>
        <li>프로그램을 객체라는 단위로 구성하여 문제를 해결하는 방법론</li>
        <li>객체는 데이터(속성)와 그 데이터에 동작하는 함수(메소드)를 묶은 하나의 단위</li>
        <li>클래스를 상속하거나 객체를 재사용하여 코드 중복을 줄일 수 있다</li>
        <li>객체별로 데이터를 관리하고 메소드를 정의하므로 프로그램 구조를 쉽게 이해하고 수정할 수 있다</li>
        <li>새로운 기능을 추가하거나 변경할 때 기존 코드를 많이 수정하지 않고도 확장이 가능하다</li>
    </ul>

    <h3>클래스</h3>
    <ul>
        <li>객체가 가질 속성과 동작을 정의</li>
        <li>객체는 클래스의 인스턴스이다</li>
    </ul>

    <h3>객체</h3>
    <ul>
        <li>객체는 클래스를 바탕으로 생성된 실체이다</li>
        <li>각 객체는 자신의 속성값을 가질 수 있다</li>
    </ul>

    <h3>상속</h3>
    <ul>
        <li>상속은 한 클래스가 다른 클래스의 속성과 메소드를 물려받을 수 있게 해주는 기능이다</li>
        <li>부모 클래스의 특성을 자식 클래스가 물려받는다</li>
        <li>자식 클래스는 추가적인 특성을 가질 수 있다</li>
    </ul>

    <h3>캡슐화</h3>
    <ul>
        <li>캡슐화는 객체의 속성이나 메소드를 외부에서 직접 접근하지 못하도록 제한하고 객체가 데이터를 처리하는 방법을 은닉한다</li>
        <li>주로 private 또는 protected 접근 제어자를 사용하여 데이터 보호를 구현한다</li>
        <ul>
            <li>캡슐화된 데이터를 다른 객체나 계층으로 전달하기 위해서 DTO나 Getter/Setter를 사용한다</li>
            <li>DTO는 객체 간에 데이터를 안전하게 전달하기 위한 구조체 역할을 한다</li>
        </ul>
    </ul>

    <h3>다형성</h3>
    <ul>
        <li>다형성은 같은 이름의 메소드나 연산자가 다른 방식으로 동작하는 것을 의미한다</li>
        <li>주로 메소드 오버라이딩 또는 인터페이스 구현을 통해 다형성을 구현한다</li>
    </ul>

    <h3>추상화</h3>
    <ul>
        <li>내부 구현은 복잡하지만 실제 노출되는 부분은 단순하게 만든다는 개념이다</li>
        <h3>추상 클래스</h3>
        <ul>
            <li>구체적인 구현을 포함하지 않고 특정 기능이나 특성을 정의만 해주는 클래스</li>
            <li>추상 클래스는 직접 객체를 생성할 수 없고 다른 클래스들이 이 클래스를 상속받아 구체적인 구현을 하도록 강제한다</li>
        </ul>
        <h3>인터페이스</h3>
        <ul>
            <li>인터페이스는 다양한 클래스들이 공통된 메소드나 속성을 정의하게 해주는 계약을 의미한다</li>
            <li>인터페이스는 구현을 거치지 않는다</li>
            <li>해당 인터페이스를 구현하는 클래스는 그 인터페이스에서 정의된 모든 메소드를 구현해야 한다</li>
        </ul>
    </ul>

    <h3>this</h3>
    <ul>
        <li>this는 현재 실행되고 있는 함수나 메소드의 문맥에 따라 다르게 동작하는 키워드</li>
        <li>this는 인스턴스 객체를 가리키며 메소드 내에서 this를 통해 그 객체의 속성이나 메소드에 접근할 수 있다</li>
    </ul>

    <h3>Super</h3>
    <ul>
        <li>자식 클래스에서 부모 클래스의 생성자나 메소드를 호출할 때 사용</li>
        <li>부모 클래스의 기능을 재사용하거나 확장할 때 유용</li>
    </ul>
</article>