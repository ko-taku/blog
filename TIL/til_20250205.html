<h2>20250205 TIL</h2>
<article>
    <h3>비트코인 블록 구조</h3>
    <p>비트코인의 블록은 블록 헤더와 블록 바디로 구성됩니다.</p>

    <h3>블록 헤더</h3>
    <p>블록 헤더는 블록에 대한 메타데이터를 포함하며, 블록의 고유 식별자 역할을 합니다. 블록 헤더의 크기는 80바이트로 고정되어 있습니다.</p>

    <h3>블록 헤더의 주요 구성 요소</h3>
    <ul>
        <li><strong>이전 블록 해시:</strong> 이전 블록의 해시 값으로, 블록 간 연결성을 제공하고 체인을 형성합니다. 블록체인의 무결성을 보장합니다.</li>
        <li><strong>머클 루트:</strong> 블록에 포함된 모든 트랜잭션의 해시 값을 결합하여 생성된 트리의 루트 해시 값입니다. 이를 통해 블록 내 모든 트랜잭션이 변경되지 않았음을 증명할 수
            있습니다.</li>
        <li><strong>타임스탬프:</strong> 블록이 생성된 시간을 나타내며, UNIX 타임스탬프 형식으로 저장됩니다. 초 단위로 기록됩니다.</li>
        <li><strong>난이도 타겟:</strong> 현재 블록 생성의 난이도를 정의하는 값입니다. 네트워크의 작업 증명 목표를 설정합니다.</li>
        <li><strong>논스 (Nonce):</strong> 작업 증명(PoW)에서 정답을 찾기 위해 반복적으로 변경되는 값입니다. 채굴자는 이 값을 변경하면서 올바른 블록 해시를 찾기 위해 시도합니다.
        </li>
        <li><strong>버전:</strong> 블록이 사용하고 있는 비트코인 프로토콜의 버전 정보입니다.</li>
    </ul>

    <h3>블록 바디</h3>
    <p>블록 바디는 트랜잭션 데이터를 저장합니다. 트랜잭션은 코인베이스 트랜잭션과 일반 트랜잭션으로 구성됩니다.</p>

    <h3>코인베이스 트랜잭션</h3>
    <p>블록을 생성한 채굴자에게 보상이 지급되는 트랜잭션입니다. 이는 항상 블록의 첫 번째 트랜잭션으로 포함됩니다.</p>

    <h3>일반 트랜잭션</h3>
    <p>블록에 포함된 비트코인 전송 기록입니다. 트랜잭션의 개수는 네트워크의 사태와 트랜잭션 용량에 따라 달라집니다.</p>

    <h3>트랜잭션 데이터 구조</h3>
    <p>트랜잭션은 입력(Input)과 출력(Output)으로 구성됩니다. 각각은 비트코인 네트워크에서 자금 흐름을 관리하는 데 중요한 역할을 합니다.</p>

    <h3>비트코인 블록 크기</h3>
    <ul>
        <li><strong>블록헤더:</strong> 고정 크기 80바이트</li>
        <li><strong>트랜잭션 데이터:</strong> 나머지 공간을 차지하며, 1MB 또는 4MB까지 처리할 수 있습니다 (SegWit 활성화 이후).</li>
    </ul>

    <h3>비트코인 블록체인의 트랜잭션 구조</h3>
    <p>비트코인 블록체인의 트랜잭션 구조는 송금 요청을 기록하고 검증하는 데 사용되는 데이터 구조입니다. 이 구조를 통해 비트코인 네트워크의 트랜잭션이 안전하게 관리됩니다.</p>

    <h3>트랜잭션의 주요 구성 요소</h3>
    <ol>
        <li><strong>버전:</strong> 트랜잭션의 형식을 정의하는 숫자 필드입니다. 현재 사용 중인 비트코인 버전은 1과 2이며, 향후 업데이트를 대비해 사용됩니다. 크기: 4바이트</li>
        <li><strong>입력:</strong> 입력은 트랜잭션이 사용하는 <strong>이전 트랜잭션의 출력(UTXO)</strong>을 참조합니다. 입력에는 송신자의 서명이 포함된 정보가 담깁니다.
        </li>
        <ul>
            <li><strong>트랜잭션 해시:</strong> 현재 트랜잭션이 참조하는 이전 트랜잭션의 해시 값입니다. 크기: 32바이트</li>
            <li><strong>출력 인덱스:</strong> 참조하는 트랜잭션에서 어떤 출력을 사용하는지 나타냅니다. (0부터 시작하는 인덱스)</li>
            <li><strong>스크립트 길이:</strong> 잠금 해제 스크립트의 길이를 나타냅니다. 크기: 가변</li>
            <li><strong>스크립트 서명:</strong> 이전 트랜잭션 출력의 소유권을 증명하기 위한 서명과 공개키로 구성된 스크립트입니다. 공개키와 디지털 서명이 포함됩니다.</li>
            <li><strong>시퀀스 번호:</strong> 트랜잭션이 취소되거나 수정될 가능성을 나타내는 필드로, 현재는 거의 사용되지 않습니다. 크기: 4바이트</li>
        </ul>
        <li><strong>출력:</strong> 출력은 수신자에게 전달되는 비트코인의 정보를 포함합니다. 한 트랜잭션은 여러 개의 출력을 가질 수 있습니다.</li>
        <ul>
            <li><strong>출력 금액:</strong> 해당 출력에 포함된 비트코인의 금액을 나타냅니다. 단위: 사토시 (1 비트코인 = 10^8 사토시). 크기: 8바이트</li>
            <li><strong>스크립트 길이:</strong> 잠금 스크립트의 길이를 나타냅니다. 크기: 가변</li>
            <li><strong>잠금 스크립트:</strong> 비트코인을 잠금(수신자의 주소를 설정)하는 스크립트입니다. 일반적으로 P2PKH 스크립트 형식을 사용하며 수신자의 주소를 포함합니다.
            </li>
        </ul>
        <li><strong>잠금 스크립트와 해제 스크립트 예시</strong></li>
        <ul>
            <li><strong>P2PKH (Pay-to-PubKey-Hash) 형식</strong></li>
            <li><strong>잠금 해제 스크립트 (ScriptSig):</strong> 입력에서 사용되며, 이전 트랜잭션 출력의 소유권을 증명하기 위해 사용됩니다. 예:
                <code>&lt;Signature&gt; &lt;Public Key&gt;</code>
            </li>
            <li><strong>잠금 스크립트 (ScriptPubKey):</strong> 출력에서 사용되며, 수신자에게 비트코인을 보낼 주소를 지정합니다. 예:
                <code>OP_DUP OP_HASH160 &lt;Recipient's Public Key Hash&gt; OP_EQUALVERIFY OP_CHECKSIG</code>
            </li>
        </ul>
        <li><strong>트랜잭션 카운터:</strong> 트랜잭션에 포함된 입력과 출력의 개수를 기록합니다. 각각 입력 개수와 출력 개수를 별도로 저장하며, 네트워크가 각 트랜잭션의 크기를 빠르게 파악할
            수 있게 합니다. 크기: 가변 (1바이트 이상, 비트코인 직렬화와 규칙에 따라 달라짐)</li>
        <li><strong>잠금 시간:</strong> 해당 트랜잭션이 유효해지는 조건을 나타냅니다. 특정 블록 높이 또는 타임스탬프가 설정될 수 있으며, 이 조건이 충족되어야 트랜잭션이 유효합니다. 크기:
            4바이트</li>
    </ol>

    <h3>트랜잭션 흐름의 요약</h3>
    <ul>
        <li>송신자는 입력에서 이전 트랜잭션 출력을 참조합니다.</li>
        <li>해당 입력에 개인 키로 디지털 서명을 생성하여 서명 스크립트(ScriptSig)에 포함합니다.</li>
        <li>송신자는 비트코인을 보낼 수신자의 주소를 출력에 지정하며, 잠금 스크립트(ScriptPubKey)를 생성합니다.</li>
        <li>수신자는 잠금 스크립트를 해제하기 위해 자신의 공개 키와 서명을 제공합니다.</li>
        <li>네트워크 노드는 입력과 출력의 검증을 수행하여 트랜잭션이 올바른지 확인합니다.</li>
    </ul>

    <h3>UTXO (미사용 트랜잭션 출력)</h3>
    <p>UTXO는 출력에서 미사용된 상태인 트랜잭션을 말합니다. 비트코인 네트워크에서 사용자의 잔고와 트랜잭션을 추적하는 기본 단위입니다. 사용자가 보유한 비트코인의 총량은 해당 사용자가 소유한 UTXO의
        합계로 계산됩니다.</p>

    <h3>트랜잭션 검증</h3>
    <p>UTXO는 트랜잭션의 입력으로 참조되며, 이미 소비된 UTXO는 다시 사용할 수 없기 때문에 이중 지불을 방지합니다.</p>

    <h3>UTXO 동작 방식</h3>
    <ul>
        <li><strong>생성:</strong> 트랜잭션의 출력으로 새 UTXO가 생성됩니다. 이 출력은 비트코인 주소로 잠겨 있으며, 해당 주소의 소유자만이 이를 소비할 수 있습니다.</li>
        <li><strong>소비:</strong> 트랜잭션의 입력은 기존 UTXO를 참조하여 소비됩니다. 소비된 UTXO는 더 이상 유효하지 않으며, 새로운 UTXO가 생성됩니다.</li>
    </ul>

    <h3>UTXO 구조</h3>
    <ul>
        <li><strong>금액:</strong> 해당 UTXO에 저장된 비트코인의 양</li>
        <li><strong>트랜잭션 스크립트:</strong> 소유자 정보가 저장된 트랜잭션 스크립트 형태</li>
        <li><strong>트랜잭션 ID:</strong> 이 UTXO를 생성한 트랜잭션의 고유 식별자</li>
        <li><strong>출력 인덱스:</strong> 해당 트랜잭션에서 이 UTXO가 몇 번째 출력인지를 나타내는 번호</li>
    </ul>

    <h3>참고</h3>
    <p>채굴자에게 지급된 수수료는 독립된 UTXO로 생성되지 않고, 블록 보상의 일부로 코인베이스 트랜잭션에 포함됩니다. 이 코인베이스 트랜잭션은 블록을 채굴했을 때 처음에 한 번만 제공됩니다.</p>

    <h3>UTXO와 트랜잭션의 관계</h3>
    <ul>
        <li><strong>트랜잭션 입력:</strong> 기존 UTXO를 참조하여 해당 금액을 소비합니다.</li>
        <li><strong>트랜잭션 출력:</strong> 새로운 UTXO를 생성하여 수신자 또는 잔돈으로 보냅니다.</li>
        <li><strong>이중 지불 방지:</strong> 이미 소비된 UTXO는 다시 사용할 수 없으므로 동일 금액을 반복 사용하려는 시도를 방지합니다.</li>
    </ul>

    <h3>UTXO의 저장 및 관리</h3>
    <ul>
        <li><strong>잔고 계산:</strong> 사용자의 잔고는 그들이 보유한 모든 잔돈 UTXO의 합계로 계산됩니다. 비트코인 네트워크는 계좌 방식이 아니라 독립적인 UTXO 목록을 통해 잔고를
            추적합니다.</li>
        <li><strong>UTXO 세트:</strong> 네트워크 노드는 전체 네트워크의 사용되지 않은 출력 목록(UTXO 세트)을 유지합니다. 이 목록은 새로운 트랜잭션을 생성할 때 입력으로 사용할 수
            있는 UTXO를 추적합니다. 트랜잭션 검증 시 참조된 UTXO의 유효성을 확인하는 데 사용됩니다.</li>
        <li><strong>저장소 요구사항:</strong> 시간이 지남에 따라 트랜잭션 수와 사용되지 않은 출력이 누적되어 UTXO 세트의 크기가 증가합니다. 이는 네트워크의 저장소와 처리 부담을
            증가시키며, 각 노드는 최신 UTXO 세트를 유지하기 위해 상당한 저장소를 요구합니다.</li>
    </ul>

    <h3>UTXO의 장점과 단점</h3>
    <ul>
        <li><strong>장점:</strong>
            <ul>
                <li><strong>보안성:</strong> UTXO는 이중 지불을 방지하고 네트워크 무결성을 보장합니다.</li>
                <li><strong>병렬 처리 기능:</strong> 서로 독립적인 UTXO를 사용하면 병렬로 트랜잭션을 처리할 수 있습니다. 이를 통해 트랜잭션 처리 속도가 빨라지고, 더 많은
                    사용자가 네트워크를 이용할 수 있습니다.</li>
            </ul>
        </li>
        <li><strong>단점:</strong>
            <ul>
                <li><strong>복잡한 잔돈 관리:</strong> 트랜잭션마다 잔돈 UTXO가 새로 생성되므로 UTXO 세트가 빠르게 증가할 수 있습니다.</li>
                <li><strong>저장소 부담:</strong> 전체 네트워크의 UTXO 데이터를 유지하는 데 상당한 저장소가 필요합니다.</li>
            </ul>
        </li>
    </ul>

    <h3>UTXO 소비 시 스크립트 언어 사용</h3>
    <ul>
        <li><strong>UTXO를 소비하려면 스크립트 언어를 통해 트랜잭션의 유효성을 확인해야 합니다.</strong></li>
        <li><strong>UTXO 검증(연산자 사용):</strong>
            <ul>
                <li><strong>소유권 검증:</strong> OP_CHECKSIG와 OP_HASH160을 활용하여 소유자를 확인합니다.</li>
                <li><strong>출력 검증:</strong> OP_EQUAL과 OP_VERIFY를 통해 출력 주소와 금액이 올바른지 확인합니다.</li>
                <li><strong>보안성 강화:</strong> OP_DUP과 OP_CHECKMULTISIG로 다중 서명 및 공개 키 변조 방지를 강화합니다.</li>
            </ul>
        </li>
    </ul>
    <h3>머클 루트</h3>
    <p>**머클 트리(Merkle Tree)**는 여러 데이터에 대해 단계적으로 해시 함수를 적용하여 최종적으로 **머클 루트(Merkle Root)**라는 하나의 최상단 해시값을 생성하는 데이터 구조입니다.
        구체적으로 블록체인의 각 트랜잭션 데이터를 해싱한 값들을 결합하여 부모 노드를 만들고, 이를 반복하여 루트 노드를 생성합니다.</p>
    <p><strong>목적:</strong> 데이터의 무결성을 보장하고 위변조를 방지하기 위해 사용됩니다.</p>

    <h3>머클 트리의 동작 과정</h3>
    <ol>
        <li><strong>트랜잭션 해싱:</strong>
            <ul>
                <li>블록에 포함된 각 트랜잭션의 해시값을 계산합니다.</li>
                <li>예를 들어, 트랜잭션 A와 트랜잭션 B의 해시값을 계산한 후 H(A)와 H(B)를 SHA-256 해싱합니다.</li>
                <li>각 해시값은 256비트 크기의 해시 값을 가집니다.</li>
            </ul>
        </li>
        <li><strong>결합:</strong>
            <ul>
                <li>두 해시값을 결합하면 512비트의 값이 됩니다.</li>
                <li>이 512비트 값을 다시 SHA-256 해싱하여 부모 노드를 생성합니다.</li>
            </ul>
        </li>
        <li><strong>반복:</strong>
            <ul>
                <li>이러한 과정을 반복하여 트리의 최상단에 머클 루트를 도출합니다.</li>
            </ul>
        </li>
        <li><strong>머클 루트 생성:</strong>
            <ul>
                <li>모든 트랜잭션을 해싱하고 결합하여 마지막으로 최상단의 머클 루트가 생성됩니다.</li>
                <li>이 최상단의 해시값은 블록 헤더에 포함되어 블록의 고유성을 보장합니다.</li>
            </ul>
        </li>
    </ol>

    <h3>예시</h3>
    <p>트랜잭션 H(A)와 H(B)는 각각 SHA-256 해싱을 통해 256바이트의 해시값을 가지며, 이 두 값을 결합하여 다시 SHA-256 해싱을 진행합니다. 이 과정을 반복하여 최상단 머클 루트가
        도출됩니다.</p>
    <p><strong>참고:</strong> 패딩이 필요 없는 이유는 첫 번째 해싱에서 입력 크기에 따라 패딩이 추가될 수 있지만, 두 번째 해싱에서는 256바이트로 고정된 길이를 처리하기 때문에 패딩이 필요
        없습니다.</p>

    <h3>머클 루트의 중요성</h3>
    <ul>
        <li><strong>블록 헤더:</strong> 머클 루트는 블록 헤더에 저장되며 블록체인 네트워크에서 작업 증명을 수행할 때 중요한 역할을 합니다. 블록의 무결성을 증명하고, 트랜잭션의 변경 여부를
            빠르게 확인할 수 있도록 해줍니다.</li>
        <li><strong>경량화된 노드:</strong> **경량화된 노드(Light Client)**는 블록체인의 전체 데이터를 다운로드하지 않고, 머클 루트를 사용해 특정 트랜잭션의 유효성을 검증할 수
            있습니다. 이를 통해 저장소와 네트워크 대역폭을 절약하면서도, 블록체인의 데이터를 검증할 수 있습니다.</li>
        <li><strong>보안과 투명성:</strong>
            <ul>
                <li><strong>트랜잭션 변경 시 머클 루트가 달라짐:</strong> 블록 내에서 하나의 트랜잭션 값이 변경되면 머클 루트가 달라지고, 이로 인해 블록 해시 값이 변경됩니다.
                </li>
                <li><strong>블록체인의 연쇄 구조:</strong> 각 블록은 이전 블록의 해시값을 포함하므로, 한 블록의 변경은 연쇄적으로 다른 블록의 해시 값도 변경하게 됩니다.</li>
                <li><strong>위변조 방지:</strong> 트랜잭션을 악의적으로 변경하면 해당 트랜잭션으로 인해 머클 루트 값이 달라지고, 이로 인해 전체 블록체인의 무결성이 깨집니다.</li>
            </ul>
        </li>
    </ul>

    <h3>블록체인의 무결성과 합의 매커니즘</h3>
    <ul>
        <li><strong>블록체인은 무결성을 보장하기 위해 머클 루트를 사용하고, 51% 공격 방어를 통해 보안성을 강화합니다.</strong></li>
        <li><strong>51% 공격:</strong> 악의적인 노드가 변경된 체인을 네트워크에 전파하더라도, 네트워크 전체 노드의 51% 이상에 해당하는 컴퓨팅 파워를 확보하지 않는 한 이 체인은
            유효하지 않은 것으로 간주됩니다.</li>
    </ul>

    <h3>결론</h3>
    <p>머클 트리와 머클 루트는 블록체인에서 트랜잭션의 무결성을 보장하고, 데이터 위변조를 방지하는 중요한 역할을 합니다. 또한, 경량화된 노드를 가능하게 하여 블록체인 네트워크의 효율성과 보안성을 높이는
        중요한 기술입니다.</p>
    <h3>비트코인 코어 설치 및 테스트넷 노드 운용 실습</h3>

    <h3>1. Homebrew 설치 및 버전 확인</h3>
    <ol>
        <li>Homebrew가 설치되어 있지 않다면 먼저 설치 후 버전을 확인합니다.</li>
        <li>버전 확인 명령어:
            <pre>brew --version</pre>
        </li>
    </ol>

    <h3>2. Bitcoin Core 설치</h3>
    <ol>
        <li>Homebrew를 통해 Bitcoin Core를 설치합니다.</li>
        <li>설치 명령어:
            <pre>brew install bitcoin</pre>
        </li>
        <li>설치 후 비트코인 CLI 버전 확인:
            <pre>bitcoin-cli --version</pre>
        </li>
    </ol>

    <h3>3. 비트코인 데이터 저장 디렉토리 생성</h3>
    <ol>
        <li>비트코인 데이터를 저장할 디렉토리를 생성하고 해당 디렉토리로 이동합니다.</li>
        <li>디렉토리 생성 명령어:
            <pre>mkdir bitcoin_data</pre>
        </li>
        <li>디렉토리로 이동:
            <pre>cd bitcoin_data</pre>
        </li>
        <li>현재 디렉토리 경로를 확인 후 나온 경로를 메모에 복사해 둡니다.</li>
        <li>디렉토리 경로 확인 명령어:
            <pre>pwd</pre>
        </li>
    </ol>

    <h3>4. 비트코인 설정 파일 생성 및 테스트넷 모드 설정</h3>
    <ol>
        <li>bitcoin.conf 파일을 생성하고 테스트넷 모드로 설정합니다.</li>
        <li>설정 파일 생성 명령어:
            <pre>vim bitcoin.conf</pre>
        </li>
        <li>다음 내용을 입력한 후 저장합니다:
            <pre>
regtest=1
server=1
rpcuser=user
rpcpassword=password
datadir=(pwd 후 나온 경로를 붙여넣기)
fallbackfee=0.0002
      </pre>
        </li>
        <li>rpcuser와 rpcpassword는 나중에 bitcoin-cli에서 인증에 사용됩니다.</li>
    </ol>

    <h3>5. 로컬 비트코인 네트워크 실행</h3>
    <ol>
        <li>새로운 터미널을 열고 로컬 비트코인 네트워크를 실행합니다.</li>
        <li>실행 명령어:
            <pre>bitcoind -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf</pre>
        </li>
    </ol>

    <h3>6. 블록체인 동기화 확인</h3>
    <ol>
        <li>기존 터미널에서 실행을 확인합니다.</li>
        <li>동기화 상태 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getblockchaininfo</pre>
        </li>
        <li>출력 결과에 "chain": "regtest"가 포함되어 있어야 합니다.</li>
        <li>"blocks": 노드가 블록체인에서 다운로드 받은 블록 수</li>
        <li>"headers": 네트워크에서 사용 가능한 최신 블록 헤더 수</li>
        <li>"verificationprogress": 네트워크와 동기화 진행률 예:
            <ul>
                <li>"verificationprogress": 0.0001 → 동기화 초기 단계.</li>
                <li>"verificationprogress": 1 → 동기화 완료.</li>
            </ul>
        </li>
    </ol>

    <h3>7. 테스트넷용 지갑 주소 생성</h3>
    <ol>
        <li>테스트넷용 지갑 주소를 생성합니다.</li>
        <li>지갑 생성 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf createwallet "(이름)"</pre>
        </li>
    </ol>

    <h3>8. 지갑 주소 확인</h3>
    <ol>
        <li>생성된 지갑 주소를 확인합니다.</li>
        <li>지갑 주소 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getnewaddress</pre>
        </li>
        <li>생성된 지갑 주소는 다른 곳에 복사해 놓습니다.</li>
    </ol>

    <h3>9. 지갑 잔액 확인</h3>
    <ol>
        <li>생성된 비트코인 지갑의 잔액을 확인합니다.</li>
        <li>잔액 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getbalance</pre>
        </li>
    </ol>

    <h3>10. 블록 채굴</h3>
    <ol>
        <li>채굴 명령어를 실행하여 블록을 생성합니다.</li>
        <li>채굴 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf generatetoaddress 101 (복사한 지갑 주소)</pre>
        </li>
        <li>101은 생성할 블록 수입니다. 101개의 블록을 채굴해야 하는 이유는 비트코인 프로토콜에서 새로 생성된 코인을 바로 사용할 수 없도록 제한하기 때문입니다. 이는 체인 리오르그를 방지하고
            네트워크 안정성을 높이는 역할을 합니다.</li>
    </ol>

    <h3>11. 블록 생성 후 잔액 확인</h3>
    <ol>
        <li>블록 생성 후 잔액을 확인합니다.</li>
        <li>잔액 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getbalance</pre>
        </li>
    </ol>

    <h3>12. 사용 가능한 UTXO 확인</h3>
    <ol>
        <li>사용 가능한 UTXO를 확인합니다.</li>
        <li>UTXO 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listunspent</pre>
        </li>
    </ol>

    <h3>13. 송금용 지갑 주소 생성</h3>
    <ol>
        <li>송금용 지갑 주소를 생성합니다.</li>
        <li>새로운 주소 생성 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf getnewaddress</pre>
        </li>
        <li>내 주소들을 확인하려면 다음 명령어를 사용합니다:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listreceivedbyaddress 0 true</pre>
        </li>
    </ol>

    <h3>14. 비트코인 송금</h3>
    <ol>
        <li>새로 생성한 주소로 비트코인을 송금합니다.</li>
        <li>송금 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf sendtoaddress <받는 주소> <금액></pre>
        </li>
    </ol>

    <h3>15. 트랜잭션 상태 확인</h3>
    <ol>
        <li>트랜잭션 상태를 확인합니다.</li>
        <li>상태 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf gettransaction (트랜잭션 ID)</pre>
        </li>
    </ol>

    <h3>16. 트랜잭션 확정을 위해 블록 생성</h3>
    <ol>
        <li>트랜잭션 확정을 위해 추가 블록을 생성합니다.</li>
        <li>블록 생성 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf generatetoaddress 10 (지갑 주소)</pre>
        </li>
    </ol>

    <h3>17. 트랜잭션 상태 재확인</h3>
    <ol>
        <li>블록 생성 후 트랜잭션 상태를 다시 확인합니다.</li>
        <li>상태 재확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf gettransaction (트랜잭션 ID)</pre>
        </li>
    </ol>

    <h3>18. 마지막으로 지갑 잔고 확인</h3>
    <ol>
        <li>내 지갑 잔고를 확인합니다.</li>
        <li>잔고 확인 명령어:
            <pre>bitcoin-cli -conf=(pwd 후 나온 경로를 붙여넣기)/bitcoin.conf listreceivedbyaddress 0 true</pre>
        </li>
        <li>listreceivedbyaddress 명령어는 특정 주소가 받은 비트코인의 총합을 표시하며, 입금된 코인의 총합만 보여주고 출금된 코인은 포함되지 않습니다.</li>
        <li>출금된 트랜잭션을 확인하려면 listtransactions 명령어를 사용해야 합니다.</li>
    </ol>
</article>